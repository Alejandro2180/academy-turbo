{
  "title": "Quiz: Lesson 5",
  "questions": [
    {
      "question": "In the lesson, what is the purpose of creating a new sub-directory named `frontend`?",
      "options": [
        {
          "answer": "To confuse learners"
        },
        {
          "answer": "To maintain good coding practices",
          "correct": true
        },
        {
          "answer": "To hide code from the compiler"
        },
        {
          "answer": "To speed up the development process"
        }
      ]
    },
    {
      "question": "What is RainbowKit kit used for in our dApp setup?",
      "options": [
        {
          "answer": "It’s responsible for the database management"
        },
        {
          "answer": "It tracks the blockchain transactions"
        },
        {
          "answer": "It's a testing framework"
        },
        {
          "answer": "It's a library for wallet management",
          "correct": true
        }
      ]
    },
    {
      "question": "Why is the `useEffect` hook used in the pages.js file?",
      "options": [
        {
          "answer": "To fix the hook if its code breaks"
        },
        {
          "answer": "To expose the code from RainbowKit"
        },
        {
          "answer": "To automatically update the contract's Solidity version when there's a breaking change"
        },
        {
          "answer": "To manage changes and side effects from its own functions",
          "correct": true
        }
      ]
    },
    {
      "question": "We talk about the `TierABI` in the lesson. What is it?",
      "options": [
        {
          "answer": "A React library that let’s us mint our NFT in tiers"
        },
        {
          "answer": "A way to let a smart contract communicate outside of itself",
          "correct": true
        },
        {
          "answer": "A programming language"
        },
        {
          "answer": "A styling tool for stacking designs on the user interface"
        }
      ]
    },
    {
      "question": "What did we need to get from the the WalletConnectCloud?",
      "options": [
        {
          "answer": "A personal API key for connecting the dApp to the RPC node"
        },
        {
          "answer": "A project ID",
          "correct": true
        },
        {
          "answer": "A connection to cloud storage for the NFTs"
        }
      ]
    },
    {
      "question": "Why do we create a custom `mintToken` function?",
      "options": [
        {
          "answer": "To handle error messages"
        },
        {
          "answer": "To be able to style the token’s image dynamically when minting"
        },
        {
          "answer": "To interact with the mint function from WAGMI and manage minting transaction values",
          "correct": true
        },
        {
          "answer": "To enable the minting button"
        }
      ]
    },
    {
      "question": "In the rendering part of the code, why do we use a ternary operator?",
      "options": [
        {
          "answer": "To disable the minting buttons"
        },
        {
          "answer": "To enable the minting buttons"
        },
        {
          "answer": "To display the NFT options based on user connection",
          "correct": true
        },
        {
          "answer": "To render the user’s ENS name, if they have one"
        }
      ]
    },
    {
      "question": "After minting the NFTs, where can users check their wallet's profile?",
      "options": [
        {
          "answer": "On the TierNFT website"
        },
        {
          "answer": "On OpenSea",
          "correct": true
        },
        {
          "answer": "In the /public/nfts directory"
        },
        {
          "answer": "In the `useEffect` hook"
        }
      ]
    },
    {
      "question": "What is the primary function of the `mintToken` function in the lesson?",
      "options": [
        {
          "answer": "To dynamically set minting prices"
        },
        {
          "answer": "To facilitate wallet connections"
        },
        {
          "answer": "To log transaction details for minted NFTs"
        },
        {
          "answer": "To handle conditional rendering of NFT cards"
        },
        {
          "answer": "To initiate the minting process for NFTs",
          "correct": true
        }
      ]
    },
    {
      "question": "How is error handling enhanced in the `mintToken` function?",
      "options": [
        {
          "answer": "With a big, red, digital, teacher’s pen"
        },
        {
          "answer": "By using a `catch` statement",
          "correct": true
        },
        {
          "answer": "By disabling mint buttons if the user doesn’t have enough to mint those tokens"
        },
        {
          "answer": "By slowing down the minting process"
        }
      ]
    }
  ]
}
