---
i18n: "smart-contracts"
title: Connecting to a Front-end
description: Connect your smart contract to a UI for people to interact with.
icons: ["rainbowkit", "wagmi", "viem"]
author: "ropats16"
---

import LessonLayout from "../../../components/LessonLayout";
import LessonQuestionsModal from "../../../components/mdx/LessonQuestionsModal";
import LessonInformationalModal from "../../../components/mdx/LessonInformationalModal";
import Question from "../../../components/mdx/Question";
import Callout from "../../../components/mdx/Callout";
import QuizStatusChecker from "../../../components/mdx/QuizStatusChecker";

{/* title="Lesson 5: Connecting to a Front-end" */}

<LessonLayout
  lessonTitle="Connect your Smart Contract to a Front End Application."
  author="ropats16"
  authorImage="/authors/ropats16.jpg"
  authorPosition="D_D Academy"
  authorTwitter="ropats16"
  createdDate="September 22, 2022"
>
## About this lesson
Congratulations on making it to this final tutorial in a series on smart contract 
development of the ERC-721 standard, a.k.a. NFTs. In the first in the track, you 
created a basic smart contract using Remix. Then a shift to a dedicated developer's 
environment to create and deploy an NFT contract to an actual test network. In 
lesson 3 you added tiers to your NFTs, finally learning to make your contracts 
air-tight by building your own automated testing suite in the fourth of the series.

But to create a full stack decentralised application, we also need a
UI, or front-end for users to interact with. In this lesson that is exactly what
we're going to create.

{/* We may as well comment out the following paragraph for this first PR of July/August 2023, since without any quizzes, it's not yet relevant: */}
{/* You can expect our familiar checkpoint questions throughout the tutorial for testing your previous knowledge, how well you‚Äôre picking up the new material, and even some on predicting upcoming steps in the lesson. They all help with critical thinking and active engagement. You'll find the updated code in side-drawers too as you progress, handy for identifying any pesky syntax errors you might come across. And of course, there is a final quiz waiting for you on completion. */}

Expect somewhere from one to four hours to complete the lesson, depending on your
prior experience and the need to grasp new concepts. We encourage you to maintain a
steady pace and encourage breaks for rejuvenation. So remind yourself to "go touch grass" and appreciate
nature's role in enhancing our well-being. üå± Relish your journey in development
in a good state of mind and body.

<LessonQuestionsModal
  buttonText="Warm-up Questions"
  title="Some previous knowledge... some prediction"
>
  <Question question="lesson-5/1-intro/Q1" />
  <Question question="lesson-5/1-intro/Q2" />
  <Question question="lesson-5/1-intro/Q3" />
  <Question question="lesson-5/1-intro/Q4" />
  <Question question="lesson-5/1-intro/Q5" />
</LessonQuestionsModal>

## What are we building

Now we're going use all of this knowledge and create a basic **NFT minting application**
that displays the three tiers of NFTs created in our smart contract and gives users
a one-click option to mint them. Once minted, users will be redirected to a page
that displays information of their mint. We'll need some extra magic to make that
all happen.

For handling wallet connections to our application, we'll be introducing you to _RainbowKit_.
And using the provided _hooks_ from _WAGMI_, we can check the connection to the
wallet and call functions from our smart contract through the front-end.
RainbowKit and WAGMI are just another couple of shining examples of open source
public goods. We love open source at Developer DAO. And public goods are gooood!

## Let's breakdown the lesson

{/* We could do with a oneliner for each to  describe what index.tsx and _app.tsx are for */}

- Set up our development environment with TierNFT project
- Create main application with Next.js, RainbowKit and WAGMI
  {/* - "a main entry point for displaying ..." needs a clearer definition */}
- Create an Index page as main entry point for displaying the app content
- Create NFT cards
- Enable minting of NFTs in the application
- Lesson Summary

<br />

## Tools to get the job done

- [RainbowKit](https://www.rainbowkit.com/docs/introduction) - a React library
  for out-of-the-box wallet management
- [Next.js](https://nextjs.org/) - a React framework for building a full-stack
  app
- [viem](https://viem.sh/docs/getting-started.html) - a compact JavaScript
  library for interacting with the Ethereum eco-system
- [WAGMI](https://wagmi.sh/) is a collection of React hooks that allows us to
  work effectively with Ethereum
- [Alchemy](https://dashboard.alchemy.com/) is an RPC provider that lets our app
  connect to the blockchain
- [WalletConnect](https://cloud.walletconnect.com/sign-in) - is a bridge that
  connects Decentralized Applications (DApps) to your web3 wallet

\* _always make sure you access up-to-date release notes and documentation_

Let's dive in!

<br />

## Getting started

We're going to start where we left off in _Write Automated Tests for your
TierNFT_.

Open your code editor and `cd` into the **`tierNFT`** project directory. For all
things related to our front-end we are going to create a new sub-directory
within our project's root directory to maintain good practice, keep our code
clean, and be easy to locate and read. The first step is to initiate a _Next.js_
application.

<Callout emoji="üí°">Make sure you are in your project's root directory before continuing.</Callout>

The next command creates a sub-directory named `frontend` inside our root
directory and sets up all the necessary files and folders within it:

```bash
# use the RainbowKit starter to create our your Next.js application with RainbowKit
npm init @rainbow-me/rainbowkit@0.2.11 --force
```

All you'll need to pick is the name of your project, which will be `frontend`:

```bash
üåà Welcome to RainbowKit!

‚úî What is the name of your project? ‚Ä¶ frontend

üöÄ Creating a new RainbowKit app in ((path)):/developerdao/frontend
```

When this command finishes running you'll see:

```bash
üåà Done! Thanks for using RainbowKit üôè
```

Once the setup is complete, we open the `frontend` directory and get cracking.

```bash
cd frontend
```

<Callout emoji="üí°">
  Bug fix: You'll need to manually edit `package.json` and change `"@rainbow-me/rainbowkit":
  "^2.0.0",` to `"@rainbow-me/rainbowkit": "^1.0.0",`. This lesson is based on RainbowKit 1.x.
</Callout>

Try running the site to see if everything is working as expected:

```bash
npm install
npm run dev
```

You'll see a message that says which url to view your site at.
It should say <strong>http://localhost:3000</strong>

<br />

---

## The Front-end

For users to easily interact with our smart contract and mint the NFTs we must
provide an interface. A simple process that is easily accessible. Let's start by
creating a way to handle wallet connections.

### The Main Application

RainbowKit and its dependencies are already installed and ready-to-go.

To get this setup we need to start working on the `pages/_app.tsx` file in the
`/frontend/pages` directory. The file should look something like this from our
initial setup:

- `import '@rainbow-me/rainbowkit/styles.css';` gives us some basic styling from
  Rainbowkit.
- `import { getDefaultWallets, RainbowKitProvider, } from '@rainbow-me/rainbowkit';`
  returns the default wallet provider option and a RainbowKit Provider to "wrap"
  around our app so that we can use its features throughout the app's pages and
  components.
- `import { polygonMumbai, configureChains, createClient, WagmiConfig, } from 'wagmi';`
  provides a way to configure the WagmiConfig wrapper for our app based on the
  chains and providers of our choice along with some other customisations.
- `import { alchemyProvider } from 'wagmi/providers/alchemy';` and
  `import { publicProvider } from 'wagmi/providers/public';` give us the
  provider configs for the providers we will be using. In our app we are using
  an `alchemyProvider` along with a fall back `publicProvider`. A provider
  allows our application to communicate with a blockchain.
  {/* It would be better to have a side drawer on 'state' and 'useEffect' here. We already have a few external links, and  we have hardly built anything so far in this lesson. That's a lot of potential rabbitholes. We could add the sidedrawers in at the end of this chunk before a checkpoint set */}
- `useEffect` and `useState` are react hooks that help us perform side effects
  and capture the state, respectively. More on
  [state](https://www.freecodecamp.org/news/what-is-state-in-react-explained-with-examples/)
  and the
  [useEffect](https://www.freecodecamp.org/news/react-useeffect-absolute-beginners/)
  hook.

<Callout emoji="üí°">
  Hooks are JavaScript functions that manage the state's behaviour and side effects by isolating
  them from a component.
</Callout>

Next we'll be configuring our application.

We save our configuration in a file called `.env` in the root of our `frontend` directory.

Create a new `.env.local` file with this content, and we'll be filling it in with real content next.

```dotenv
NEXT_PUBLIC_PROJECT_ID=
NEXT_PUBLIC_ALCHEMY_ID=
NEXT_PUBLIC_CONTRACT_ADDRESS=
NEXT_PUBLIC_ENABLE_TESTNETS=true
```

Add your `NEXT_PUBLIC_ALCHEMY_ID`. This is your API Key from Alchemy.

Our dApp is also using WalletConnect, so we need a `projectID`
from the [WalletConnectCloud](https://cloud.walletconnect.com/sign-in).
So go and set up an account and grab that ID. You'll be done in a few minutes ü§ó

For this application we will continue using the `mumbai` testnet. Other chains
can be added simply using the following syntax: `chain.chain_name`. For custom
providers, like the `alchemyProvider` we can pass in our private `apiKey` as
well.

Lastly add your `NEXT_PUBLIC_CONTRACT_ADDRESS` which is the address of your deployed on mumbai testnet.

Now we need to add these new environment variables to our codebase.

In `_app.tsx` Replace `projectId: 'YOUR_PROJECT_ID',` with `projectId: process.env.NEXT_PUBLIC_PROJECT_ID || "",`.

We're going to continue to use Alchemy as our provider for connecting to `mumbai` testnet.

Please make these changes to `_app.tsx`:

- replace `import { publicProvider } from "wagmi/providers/public";` with `import { alchemyProvider } from "wagmi/providers/alchemy";` at the top of the file.
- in `configureChains` section, replace `[publicProvider()]` with `[alchemyProvider({ apiKey: process.env.NEXT_PUBLIC_ALCHEMY_ID || "" })]`.
- search and replace `goerli` (which is Ethereum's testnet) and replace with `polygonMumbai`.
- remove `zora` from `wagmi/chains` import and from the `configureChains` array.

Now that we have our application setup, we can edit the Index Page.

<br />

---

### The Index Page

Notice that we are using the `page folder routing` in our app, which give us an
`index.tsx` page in the `/frontend/pages` directory. This file work as our
homepage at the root level, in our url will be `htpp://localhost:3000/` by
default.

We'll only make one change to this file. We'll bring in a brand new `<TierNFT>` React component
that will house our main application functionality and will be displayed on the Home page.

Open `frontend/pages/index.tsx` and add these two lines:

```tsx
import { TierNFT } from "../components/tiernft";
```

```tsx
<main className={styles.main}>
  <TierNFT />
</main>
```

so your file should look like this:

```tsx
import type { NextPage } from "next";
import Head from "next/head";
import { TierNFT } from "../components/tiernft";
import styles from "../styles/Home.module.css";

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>RainbowKit App</title>
        <meta content="Generated by @rainbow-me/create-rainbowkit" name="description" />
        <link href="/favicon.ico" rel="icon" />
      </Head>

      <main className={styles.main}>
        <TierNFT />
      </main>
    </div>
  );
};

export default Home;
```

Before we can run this, we need to now create the `TierNFT` component.

Create a new folder called `components` in the `/frontend` directory and inside create `tiernft.tsx`
that will contain the following code:

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import {
  useAccount,
  useContractEvent,
  useContractRead,
  useContractWrite,
  usePrepareContractWrite,
  useWaitForTransaction,
} from "wagmi";
import TierABI from "../artifacts/contracts/TierNFT.sol/TierNFT.json";
import { Log, formatUnits, parseEther } from "viem";
import { CSSProperties, useEffect, useState } from "react";
import Image from "next/image";

type LogWithArgs = Log & {
  args: { from: string; to: string; tokenId: bigint };
};

export function TierNFT() {
  const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS as `0x${string}`;

  const { isConnected, address } = useAccount();

  const [isUserConnected, setIsUserConnected] = useState(false);
  const [latestNFTMinted, setLatestNFTMinted] = useState<{
    name: string;
    image: string;
  }>({ name: "", image: "" });
  const [modalShow, setModalShow] = useState(false);
  const [mintingPrice, setMintingPrice] = useState("0");
  const [mintedTokenId, setMintedTokenId] = useState<bigint | undefined>(undefined);

  const { config } = usePrepareContractWrite({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "mint",
    value: parseEther(mintingPrice),
    onError: (e) => {
      console.log("Error minting NFT", e);
    },
    enabled: mintingPrice !== "0",
  });

  const { data: mintData, writeAsync: mint, isLoading: isMintLoading } = useContractWrite(config);

  const { data: txData } = useWaitForTransaction({
    hash: mintData?.hash,
  });

  useEffect(() => {
    if (mintingPrice !== "0" && mint) {
      setModalShow(true);
      mint();
      setMintingPrice("0");
    }
  }, [mintingPrice, mint]);

  const { data: tokenURI }: { data: any } = useContractRead({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "tokenURI",
    args: [mintedTokenId],
    watch: true,
    enabled: mintedTokenId != undefined,
  });

  useEffect(() => {
    try {
      setIsUserConnected(isConnected);
    } catch (e) {
      const error = e as Error;
      console.log("Error connecting to user", error.message);
    }
  }, [isConnected]);

  // await for mint to complete
  const unwatch = useContractEvent({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    eventName: "Transfer",
    listener(events) {
      if (events.length === 0) {
        return;
      }
      events.forEach((event) => {
        const extendedEvent = event as LogWithArgs;
        const { to, tokenId } = extendedEvent.args;
        if (to === address) {
          setMintedTokenId(tokenId);
          unwatch?.();
        }
      });
    },
  });

  useEffect(() => {
    try {
      if (tokenURI) {
        setLatestNFTMinted(JSON.parse(window.atob(tokenURI.substring(tokenURI.indexOf(",") + 1))));
      }
    } catch (e) {
      const error = e as Error;
      console.log("Error fetching token URI", error.message);
    }
  }, [tokenURI]);

  return (
    <div className={styles.container}>
      <Head>
        <title>NFT Minter</title>
        <meta name="description" content="D_D Academy NFT Minter frontend integration project" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <header style={header}>
        <h1>TierNFTs</h1>
        <ConnectButton />
      </header>
      {isUserConnected ? (
        <main className={styles.main}>
          <div style={NFTFlex}>
            <div style={NFTCard}>
              <h2>Tier 0</h2>
              <Image src="/nfts/0_basic.svg" width="200" height="200" alt="basic tier nft" />
              <button
                onClick={() => {
                  setMintingPrice("0.01");
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              <h2>Tier 1</h2>
              <Image src="/nfts/1_medium.svg" width="200" height="200" alt="medium tier nft" />
              <button
                onClick={() => {
                  setMintingPrice("0.02");
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              <h2>Tier 2</h2>
              <Image src="/nfts/2_premium.svg" width="200" height="200" alt="premium tier nft" />
              <button
                onClick={() => {
                  setMintingPrice("0.05");
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
          </div>
          {modalShow && (
            <div style={modal}>
              {txData === undefined ? (
                <div style={modalContent}>
                  <h2>Minting...</h2>
                </div>
              ) : (
                <div style={modalContent}>
                  <h2>Mint Successful</h2>
                  <div style={modalBody}>
                    {latestNFTMinted.name && <h3>{latestNFTMinted.name}</h3>}
                    {latestNFTMinted.image && (
                      <Image
                        src={latestNFTMinted.image}
                        height="200"
                        width="200"
                        alt="Minted NFT"
                      />
                    )}
                  </div>
                  <div style={modalFooter}>
                    <button style={modalButton}>
                      {mintedTokenId != undefined && (
                        <a
                          href={`https://testnets.opensea.io/assets/mumbai/${CONTRACT_ADDRESS}/${formatUnits(
                            mintedTokenId,
                            0,
                          )}`}
                          target="_blank"
                        >
                          View on OpenSea
                        </a>
                      )}
                    </button>
                    <button style={modalButton}>
                      {txData && txData.transactionHash ? (
                        <a
                          href={`https://mumbai.polygonscan.com/tx/${txData.transactionHash}`}
                          target="_blank"
                        >
                          View on Polygonscan
                        </a>
                      ) : undefined}
                    </button>
                    <button onClick={() => setModalShow(false)} style={modalButton}>
                      Close
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}
        </main>
      ) : (
        <main className={styles.main}>
          <div>Please connect your wallet.</div>
        </main>
      )}
    </div>
  );
}

const header: CSSProperties = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "space-between",
  paddingTop: "20px",
  paddingLeft: "50px",
  paddingRight: "50px",
};

const NFTFlex: CSSProperties = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-evenly",
  gap: "50px",
};

const NFTCard: CSSProperties = {
  display: "flex",
  flexDirection: "column",
  border: "2px solid white",
  borderRadius: "10px",
  padding: "20px",
  alignItems: "center",
  gap: "10px",
  fontWeight: "bold",
};

const NFTMint: CSSProperties = {
  fontWeight: "700",
  padding: "5px 20px",
  border: "2px solid white",
  color: "white",
  backgroundColor: "black",
  borderRadius: "5px",
  cursor: "pointer",
};

const modal: CSSProperties = {
  position: "fixed",
  left: "0",
  top: "0",
  right: "0",
  bottom: "0",
  backgroundColor: "rgba(0, 0, 0, 0.8)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  zIndex: "1",
};

const modalContent: CSSProperties = {
  backgroundColor: "#fff",
  padding: "10px 30px",
  borderRadius: "16px",
  color: "#000",
};

const modalBody: CSSProperties = {
  padding: "20px",
  borderTop: "1px solid #eee",
  borderBottom: "1px solid #eee",
};

const modalFooter: CSSProperties = {
  display: "flex",
  flexDirection: "column",
  gap: "10px",
  padding: "20px",
  justifyContent: "space-evenly",
};

const modalButton: CSSProperties = {
  padding: "10px 20px",
  backgroundColor: "#fff",
  color: "#666",
  border: "0",
  borderRadius: "10px",
  fontSize: "18px",
  fontWeight: "700",
  boxShadow: "0 0.2em 0.4em 0 rgba(0, 0, 0, 0.2), 0 0.3em 1em 0 rgba(0, 0, 0, 0.19)",
  cursor: "pointer",
};
```

{/* DISCUSS STYLING? */}
{/* DISCUSS THE VARIOUS PIECES OF TIERNFT COMPONENT */}

<br />

Moving onto imports.

```jsx
// prev imports...

import { ConnectButton } from "@rainbow-me/rainbowkit";
import {
  useAccount,
  useContractRead,
  useContractWrite,
  usePrepareContractWrite,
  useWaitForTransaction,
} from "wagmi";
import TierABI from "@/artifacts/contracts/TierNFT.sol/TierNFT.json";
import styles from "@/styles/Home.module.css";
import { parseEther } from "viem";
import { useEffect, useState } from "react";
import Image from "next/image";

// function Home() code...
```

- RainbowKit provides us a ready-made `ConnectButton`.
- We need to use the `useAccount` hook from WAGMI to check account connection
  and `useContractRead` and `useContractWrite` to interact with our smart
  contract. We will look into WAGMI and these hooks a little down the line.
  {/* I eventually wanna create a side-drawer for ABI */}
- `TierABI` is our contract's Application Binary Interface (ABI). The ABI helps
  us interact with the smart contract outside the blockchain or
  contract-to-contract. You can read more about ABIs
  [here](https://www.quicknode.com/guides/solidity/what-is-an-abi).
- The `viem` library will assist us with some utilities in our code.
- Once again, `useEffect` and `useState` are react hooks that will help us
  perform side effects and capture the state, respectively.

```tsx
export default function Home() {
  const CONTRACT_ADDRESS = const CONTRACT_ADDRESS =
    process.env.NEXT_PUBLIC_TIERNFT_CONTRACT_ADDRESS || "0x5794c3de7a59587048b76060d282476e12a8aff8"; /* Or enter Contract Address between ''*/;

  const { isConnected } = useAccount();

  const [isUserConnected, setIsUserConnected] = useState(false);
  const [latestNFTMinted, setLatestNFTMinted] = useState(0);
  const [modalShow, setModalShow] = useState(false);

  // More code to come...
}
```

We're creating a default function called `Home` that will render our home/ index
page. As you can see , we are required to add the `CONTRACT_ADDRESS` which is
displayed in your command line when we deploy the contract. The `useAccount`
hook lets us access account data and check connection status. We will use this
as a check to provide access to the minting features of our app. `useState`
lets us store state information such as whether a user is connected.
The general syntax for using the `useState` hook is:

`const [variableName, functionToSetVariable] = useState(intialValue)`

<Callout emoji="üí°">
  The initial value also serves as the type for the value assigned. If the initial value is a
  string, then the values set later must be strings too. The hook can be created without an initial
  value as well but a good practice is to always choose and pass in an initial value based on the
  value type we expect to assign to that variable.
</Callout>

We will revisit these state variables later to see their implementation.

### Header

We need a `<header>` that displays our application name and lets us connect our
wallet.

```tsx
export default function Home() {
  // variable definitions...

  return (
    <div className={styles.container}>
      {/* <Head> element... */}

      <header style={header}>
        <h1>TierNFTs</h1>
        <ConnectButton />
      </header>

      {/* <main> element */}
    </div>
  );
}

// styling code...
```

Since we care about accessibility, we ensure we are using only a single `<h1>`
element on a page and the correct sub heading elements as well. The
`ConnectButton` is a direct import from `RainbowKit` that is generated using the
configurations setup previously in our Main Application.

With this setup we can run the `npm run dev` or `yarn dev` command in our
console and click the returned link (`http://localhost:portnumber`) to preview
our application. This is a good way to debug and see if our code is behaving as
expected.

<Callout emoji="üí°">
  Make sure you are in the frontend directory before running the command.
</Callout>

The preview should look like this:

![App Header Preview](/assets/lessons/5/img_1.png)

### NFT Cards

Next we need to create some cards that display the 3 tiers of NFTs we created in
our smart contract and provide a way to mint them.

```tsx
export default function Home() {
  // variable definitions...

  const { config, isLoading: isMintLoading } = usePrepareContractWrite({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "safeMint",
    value: parseEther(mintingPrice), // "0.02"
    // enabled: Boolean(mintingPrice !== "0"), // "true"
  });

  const { data: mintData, write } = useContractWrite(config);

  const { data: txData } = useWaitForTransaction({
    hash: mintData?.hash,
  });
  // return statement for rendering...
}
```

The [`useContractWrite`](https://wagmi.sh/docs/hooks/useContractWrite) hook from
WAGMI lets us pass in the contract address, contract ABI and the function name
to return a JavaScript function (that we have called `mint`) that can interact
with our smart contract and trigger a `write` function in it.

How cool is that?!

It also returns some additional features for error handling and checking whether
the function is running or completed. We are assigning well defined names to the
returned values for easily calling them later. For example, the `data` returned
is called `mintData`.

Even though we have this function, we need to pass in custom `message values`
i.e. an amount in **ETH**, as defined in our contract. For this we create our
own `mintToken` function that calls the `mint` function from WAGMI within it.

The `usePrepareContractWrite` hook also work better with the
`usePrepareContractWrite` hook as explained on
[wagmi docs](https://wagmi.sh/react/hooks/useContractWrite#prepared-usage).

```tsx
// WAGMI useContractWrite hook...

const mintToken = async (e) => {
  try {
    let mintTxn = await mint({
      recklesslySetUnpreparedOverrides: {
        value: parseEther(e.target.value),
      },
    });
    await mintTxn.wait();
    console.log("This is the mint data", mintData);
  } catch (error) {
    console.log("Error minting NFT", error.message);
  }
};

// function Home() code...
```

- We pass in `e` as an argument so that we can pick the amount of ETH associated
  with a particular Tier. This is passed to the mint function using the
  `recklesslySetUnpreparedOverrides` override config. Read more about it
  [here](https://wagmi.sh/docs/hooks/useContractWrite#override-config).
- We want to wait for our minting transaction to complete before moving on to
  other pieces of code so we use `wait()`.
- After minting is processed we log the returned data to ensure the success of
  our transaction.
- Using `try...catch` statements makes our error handling more robust. The
  compiler runs each line of code and exits in between if an error occurs. We
  can console log this error to easily identify the cause and location of the
  error with clear comments.

Then we create a new folder named `nfts` in the `/public` directory for saving
Tier SVGs. You can find links for downloading the SVGs here.

- [0_basic.svg](https://arweave.net/o9z59y3sDvBaamvBDJGtyX5BGM983n1zwbs-UaZRUM8)
- [1_medium.svg](https://arweave.net/-sa-soe34iPLridK0T98rWb7XvfHRSTDdBCoXCuwv60)
- [2_premium.svg](https://arweave.net/AG0bE-GMrUh-7YjtxlY01woT7kbwEPwgREzuPptJZBo)

Save them with the same names as shown in the links above for smooth flow in the
code.

<Callout emoji="üí°">
  Make sure you have downloaded the SVG file and not just saved the URL of the file.
</Callout>

Now we can render our NFT Cards.

```tsx
// return statement for rendering and <header> element...

<main className={styles.main}>
  <div style={NFTFlex}>
    <div style={NFTCard}>
      Tier 0
      <Image src="/nfts/0_basic.svg" width="200" height="200" alt="Basic Tier" />
      <button
        value="0.01"
        onClick={(e) => {
          setMintingPrice(e.target.value);
          mintToken();
        }}
        style={NFTMint}
        disabled={isMintLoading}
      >
        Mint
      </button>
    </div>
    <div style={NFTCard}>
      Tier 1
      <Image src="/nfts/1_medium.svg" width="200" height="200" alt="Medium Tier" />
      <button
        value="0.02"
        onClick={(e) => {
          setMintingPrice(e.target.value);
          mintToken();
        }}
        style={NFTMint}
        disabled={isMintLoading}
      >
        Mint
      </button>
    </div>
    <div style={NFTCard}>
      Tier 2
      <Image src="/nfts/2_premium.svg" width="200" height="200" alt="Premium Tier" />
      <button
        value="0.05"
        onClick={(e) => {
          setMintingPrice(e.target.value);
          mintToken();
        }}
        style={NFTMint}
        disabled={isMintLoading}
      >
        Mint
      </button>
    </div>
  </div>
</main>

// rest of the code...
```

Let's see what is happening in each NFT Card by taking `Tier 0` as an example.

```tsx
<div style={NFTCard}>
  Tier 0
  <Image src="/nfts/0_basic.svg" width="200" height="200" alt="Premium Tier" />
  <button
    value="0.01"
    onClick={(e) => {
      setMintingPrice(e.target.value);
      mintToken();
    }}
    style={NFTMint}
    disabled={isMintLoading}
  >
    Mint
  </button>
</div>
```

- We start off by displaying the NFT Tier name.
- A Next.js `Image` element renders a preview of the NFT Image. Earlier, we saved
  our images in the `/public/nfts` folder. A Next.js app automatically detects
  content from the `/public` directory so we can directly reference the source
  as `/nfts/0_basic.svg`. We also need to pass in the width and height
  explicitly.
- A `button` element lets us first set the minting price choosen and then it
  calls the `mintToken` function `onClick` and we send the value associated with
  the button to that function so that it can be used to mint the specific tier
  of NFT in the `<button>` element. Make sure you pass in the right value for
  each tier. Lastly, we want to disable the button when another mint is
  underway. For this we use the true/ false values received from
  `isMintLoading`. The button will be disabled when `isMintLoading` is `true`.

Great but anyone can view and call our mint functions in the front-end of our
app even if their wallet is not connected to the application. This could result
in some errors. We must check if a user is connected before we let them interact
with our application simply by using the `isConnected` utility from Wagmi and
setting setting its value in our `isUserConnected` state.

```tsx
// consts...

useEffect(() => {
  try {
    setIsUserConnected(isConnected);
  } catch (error) {
    console.log("Error connecting to user", error.message);
  }
}, [isConnected]);

// function Home() code...
```

The `useEffect` hook runs the functions within it everytime the value of its
dependencies, `isConnected`, in this case, changes.

Then we can wrap the `<main>` element as follows:

```tsx
// return statement for rendering...

{
  isUserConnected ? (
    <main className={styles.main}>{/* NFT Flex div code here... */}</main>
  ) : (
    <main className={styles.main}>
      <div>Please connect your wallet.</div>
    </main>
  );
}

// closing <div> and styling consts...
```

This `condition ? ifTrueDoThis : ifFalseDoThis` type of syntax is known as a
**ternary** operator. It checks whether the condition is `true` or `false` and
returns one of two values accordingly. In our case, we check if the the user is
connected and show them the mint options `if` `true`, `else` we ask them to connect
their wallet.

Now our preview should look like this once a wallet is connected:

![NFT Cards Preview](/assets/lessons/5/img_2.png)

**Woohoo! You've done a lot so far.** Try minting these NFTs and check your
wallet's profile on `https://testnets.opensea.io/YOUR_WALLET_ADDRESS`. Refer to
the following side drawer for the code written till now if stuck somewhere.

<LessonInformationalModal buttonText="Code so far for index.tsx" title="Code so far for index.tsx">

```tsx
import Head from "next/head";
import Image from "next/image";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import { useAccount, useContractRead, useContractWrite } from "wagmi";
import TierABI from "@/artifacts/contracts/TierNFT.sol/TierNFT.json";
import styles from "@/styles/Home.module.css";
import { parseEther } from "viem";
import { useEffect, useState } from "react";

export default function Home() {
  const CONTRACT_ADDRESS =
    process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || "0x5794c3de7a59587048b76060d282476e12a8aff8";
  /*Enter Contract Address between ''*/ const { isConnected } = useAccount();

  const [isUserConnected, setIsUserConnected] = useState(false);
  const [latestNFTMinted, setLatestNFTMinted] = useState(0);
  const [modalShow, setModalShow] = useState(false);
  const [mintingPrice, setMintingPrice] = useState("0");

  const { config, isLoading: isMintLoading } = usePrepareContractWrite({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "safeMint",
    value: parseEther(mintingPrice), // "0.02"
    // enabled: Boolean(mintingPrice !== "0"), // "true"
  });

  const { data: mintData, write } = useContractWrite(config);

  const { data: txData } = useWaitForTransaction({
    hash: mintData?.hash,
  });

  useEffect(() => {
    try {
      setIsUserConnected(isConnected);
    } catch (error) {
      console.log("Error connecting to user", error.message);
    }
  }, [isConnected]);

  const mintToken = async (e) => {
    if (mintingPrice !== "0") {
      try {
        setModalShow(true);
        write();
        setMintingPrice("0");
      } catch (error) {
        console.log("Error minting NFT", error.message);
      }
    } else {
      alert("Please select a tier to mint");
    }
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>NFT Minter</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <header style={header}>
        <h1>TierNFTs</h1>
        <ConnectButton />
      </header>
      {isUserConnected ? (
        <main className={styles.main}>
          <div style={NFTFlex}>
            <div style={NFTCard}>
              Tier 0
              <Image src="/nfts/0_basic.svg" width="200" height="200" alt="Basic Tier" />
              <button
                value="0.01"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              Tier 1
              <Image src="/nfts/1_medium.svg" width="200" height="200" alt="Medium Tier" />
              <button
                value="0.02"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              Tier 2
              <Image src="/nfts/2_premium.svg" width="200" height="200" alt="Premium Tier" />
              <button
                value="0.05"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
          </div>
        </main>
      ) : (
        <main className={styles.main}>
          <div>Please connect your wallet</div>
        </main>
      )}
    </div>
  );
}

const header = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  paddingTop: "20px",
  paddingLeft: "50px",
  paddingRight: "50px",
};

const NFTFlex = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-evenly",
  gap: "50px",
};

const NFTCard = {
  display: "flex",
  flexDirection: "column",
  border: "2px solid white",
  borderRadius: "10px",
  padding: "20px",
  alignItems: "center",
  gap: "10px",
  fontWeight: "bold",
};

const NFTMint = {
  fontWeight: "700",
  padding: "5px 20px",
  border: "2px solid white",
  color: "white",
  backgroundColor: "black",
  borderRadius: "5px",
  cursor: "pointer",
};

const modal = {
  position: "fixed",
  left: "0",
  top: "0",
  right: "0",
  bottom: "0",
  backgroundColor: "rgba(0, 0, 0, 0.8)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  zIndex: "1",
};

const modalContent = {
  backgroundColor: "#fff",
  padding: "10px 30px",
  borderRadius: "16px",
  color: "#000",
};

const modalBody = {
  padding: "20px",
  borderTop: "1px solid #eee",
  borderBottom: "1px solid #eee",
};

const modalFooter = {
  display: "flex",
  flexDirection: "column",
  gap: "10px",
  padding: "20px",
  justifyContent: "space-evenly",
};

const modalButton = {
  padding: "10px 20px",
  backgroundColor: "#fff",
  color: "#666",
  border: "0",
  borderRadius: "10px",
  fontSize: "18px",
  fontWeight: "700",
  boxShadow: "0 0.2em 0.4em 0 rgba(0, 0, 0, 0.2), 0 0.3em 1em 0 rgba(0, 0, 0, 0.19)",
};
```

</LessonInformationalModal>
<br/>

Take a breather and stretch yourself before we do the last bit of coding.

### Successful Mint Modal

Doesn't it feel like we are still missing something?

Right! We want our users to see information when they minting. We want them to
know when a mint _is in progress_ and we want them to see the result once the
mint _is successful_.

But what is this _modal_. It is a an element that is usually used as an overlay
that provides its own interaction environment separate from the page below it.
This interaction environment provides a focus element where only options from
this can be selected while it is active.

Okay lets write some code for it.

To be able to display information about our latest mint, we must first get
information about it from our smart contract.

```tsx
// imports, consts and WAGMI useContractWrite hook...

const { data: tokenData, refetch: refetchTokenData } = useContractRead({
  address: CONTRACT_ADDRESS,
  abi: TierABI.abi,
  functionName: "totalSupply",
  watch: true,
  enabled: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS,
});

const { data: tokenURI } = useContractRead({
  address: CONTRACT_ADDRESS,
  abi: TierABI.abi,
  functionName: "tokenURI",
  args: [1],
  watch: true,
  enabled: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS,
});

// useEffect to check user connection...

useEffect(() => {
  try {
    if (tokenURI) {
      setLatestNFTMinted(JSON.parse(window.atob(tokenURI.substring(tokenURI.indexOf(",") + 1))));
    }
  } catch (error) {
    console.log("Error fetching token URI", error.message);
  }
}, [tokenData, tokenURI]);

const mintToken = async (e) => {
  if (mintingPrice !== "0") {
    try {
      setModalShow(true);
      write();
      refetchTokenData();
      setMintingPrice("0");
    } catch (error) {
      console.log("Error minting NFT", error.message);
    }
  } else {
    alert("Please select a tier to mint");
  }
};

// JSX return statement...
```

- The first thing we need is the `tokenId` of the latest NFT minted. We can do
  so by reading the value of the `totalSupply` stored in our smart contract
  because the `totalSupply` should equal to the latest `tokenId` in our case. We
  can fetch this using the `useContractRead` hook from WAGMI that is configured
  for reading data from smart contracts. The cool thing about solidity is that
  it automatically gives us a way to read values of variables that are tagged as
  `public`, which is why we are able to read the value of `totalSupply`.
- The `refetchTokenData` function will be called in our `mintToken` function to
  update the `tokenData` after minting has succeeded. We pass a `watch: true`
  key-value pair so that the hook keeps an active watch on the value of
  totalSupply.
- Then the returned value (tokenData) is passed in as an argument to the
  `tokenURI` function from our smart contract and we receive a `Base64` encoded
  string in return.
- A `useEffect` hook keeps updating this string everytime the `tokenData` or
  `tokenURI` is updated and stores a decoded JSON format of it in the
  `latestNFTMinted` variable.

We're almost there. We just need to do two more checks before we actually look
at our modal. The first is that we must display our modal only when we want it
to and the other is to display a loading message until our NFT has successfully
minted. This is how the mintToken function should look now:

```tsx
// useEffect for tokenURI...

const mintToken = async (e) => {
  if (mintingPrice !== "0") {
    try {
      setModalShow(true);
      write();
      console.log("This is the mint data", mintData);
      refetchTokenData(); // <--------- this is the new line: here an exaplanation of the refetchTokenData() Function for i.e.
      setMintingPrice("0");
    } catch (error) {
      console.log("Error minting NFT", error.message);
      setMintingPrice("0");
    }
  } else {
    alert("Please select a tier to mint");
  }
};

// return statement...
```

When we trigger the `mintToken` function we want to set the state to
`isMinting`. Based on this condition, we can inform the users that the mint is
in progress. We also want our modal to pop up right after this so we set the
value of `modalShow` to `true`.

We're there at last! Now we can render our modal.

```tsx
// return statement for rendering...

{
  isUserConnected ? (
    <main className={styles.main}>
      <div style={NFTFlex}>{/* NFT Card div code... */}</div>
      {modalShow && (
        <div style={modal}>
          {txData === undefined ? (
            <div style={modalContent}>
              <h2>Minting...</h2>
            </div>
          ) : (
            <div style={modalContent}>
              <h2>Mint Successful</h2>
              <div style={modalBody}>
                <h3>{latestNFTMinted.name}</h3>
                <Image src={latestNFTMinted.image} height="200" width="200" alt="NFT Image" />
              </div>
              <div style={modalFooter}>
                <button style={modalButton}>
                  <a
                    href={`https://testnets.opensea.io/assets/mumbai/${CONTRACT_ADDRESS}/${
                      formatUnits(tokenData, 0) - 1
                    }`}
                    target="_blank"
                  >
                    View on OpenSea
                  </a>
                </button>
                <button style={modalButton}>
                  {txData && txData.transactionHash ? (
                    <a
                      href={`https://mumbai.polygonscan.com/tx/${txData.transactionHash}`}
                      target="_blank"
                    >
                      View on Polygonscan
                    </a>
                  ) : undefined}
                </button>
                <button onClick={() => setModalShow(false)} style={modalButton}>
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      )}
    </main>
  ) : (
    <main className={styles.main}>
      <div>Please connect your wallet</div>
    </main>
  );
}
// closing <div> and styling consts...
```

This may seem like a lot of code but we're going to look at it in bits:

- We have a heading that tells us our mint is successful.
- The body shows us the name, id and image of the NFT minted. We fetch from the
  information stored earlier in the `latestNFTMinted` variable.
- We have a footer that provides links to view our NFT on OpenSea and to the
  transaction details on Polygonscan. Additionally we have a **Close** button
  that changes the state of the `modalShow` to `false` and thus closes the modal
  modal when we click it.

The final modal should look like this:

![Successful Mint Modal Preview](/assets/lessons/5/img_3.png)

If you are stuck somewhere, please refer to the code side drawer below.

<LessonInformationalModal buttonText="Final Code for index.tsx" title="Final Code for index.tsx">

```tsx
import Head from "next/head";
import Image from "next/image";
import styles from "@/styles/Home.module.css";

import { ConnectButton } from "@rainbow-me/rainbowkit";
import {
  useAccount,
  useContractRead,
  useContractWrite,
  usePrepareContractWrite,
  useWaitForTransaction,
} from "wagmi";
import TierABI from "@/artifacts/contracts/TierNFT.sol/TierNFT.json";
import { useEffect, useState } from "react";
import { parseEther, formatUnits } from "viem";

const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || "";

export default function Home() {
  const { isConnected } = useAccount();

  const [isUserConnected, setIsUserConnected] = useState(false);
  const [latestNFTMinted, setLatestNFTMinted] = useState(0);
  const [modalShow, setModalShow] = useState(false);
  const [mintingPrice, setMintingPrice] = useState("0");

  const { data: tokenData, refetch: refetchTokenData } = useContractRead({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "totalSupply",
    watch: true,
    enabled: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS,
  });

  const { data: tokenURI } = useContractRead({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "tokenURI",
    args: [1],
    watch: true,
    enabled: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS,
  });

  useEffect(() => {
    try {
      setIsUserConnected(isConnected);
    } catch (error) {
      console.log("Error connecting to user", error.message);
    }
  }, [isConnected]);

  useEffect(() => {
    try {
      if (tokenURI) {
        setLatestNFTMinted(JSON.parse(window.atob(tokenURI.substring(tokenURI.indexOf(",") + 1))));
      }
    } catch (error) {
      console.log("Error fetching token URI", error.message);
    }
  }, [tokenData, tokenURI]);

  const { config, isLoading: isMintLoading } = usePrepareContractWrite({
    address: CONTRACT_ADDRESS,
    abi: TierABI.abi,
    functionName: "safeMint",
    value: parseEther(mintingPrice), // "0.02"
    // enabled: Boolean(mintingPrice !== "0"), // "true"
  });

  const { data: mintData, write } = useContractWrite(config);

  const { data: txData } = useWaitForTransaction({
    hash: mintData?.hash,
  });

  const mintToken = async () => {
    if (mintingPrice !== "0") {
      try {
        setModalShow(true);
        write();
        refetchTokenData(); // <--------- this is the new line: here an exaplanation of the refetchTokenData() Function for i.e.
        setMintingPrice("0");
      } catch (error) {
        console.log("Error minting NFT", error.message);
        setMintingPrice("0");
      }
    } else {
      alert("Please select a tier to mint");
    }
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <header style={header}>
        <h1>TierNFTs</h1>
        <ConnectButton />
      </header>
      {isUserConnected ? (
        <main className={styles.main}>
          <div style={NFTFlex}>
            <div style={NFTCard}>
              Tier 0
              <Image src="/nfts/0_basic.svg" width="200" height="200" alt="Basic Tier" />
              <button
                value="0.01"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              Tier 1
              <Image src="/nfts/1_medium.svg" width="200" height="200" alt="Medium Tier" />
              <button
                value="0.02"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
            <div style={NFTCard}>
              Tier 2
              <Image src="/nfts/2_premium.svg" width="200" height="200" alt="Premium Tier" />
              <button
                value="0.05"
                onClick={(e) => {
                  setMintingPrice(e.target.value);
                  mintToken();
                }}
                style={NFTMint}
                disabled={isMintLoading}
              >
                Mint
              </button>
            </div>
          </div>

          {modalShow && (
            <div style={modal}>
              {txData === undefined ? (
                <div style={modalContent}>
                  <h2>Minting...</h2>
                </div>
              ) : (
                <div style={modalContent}>
                  <h2>Mint Successful</h2>
                  <div style={modalBody}>
                    <h3>{latestNFTMinted.name}</h3>
                    <Image
                      src={latestNFTMinted.image}
                      height="200"
                      width="200"
                      alt="NFT Image" // px rem or em
                    />
                  </div>
                  <div style={modalFooter}>
                    <button style={modalButton}>
                      <a
                        href={`https://testnets.opensea.io/assets/mumbai/${CONTRACT_ADDRESS}/${
                          formatUnits(tokenData, 0) - 1
                        }`}
                        target="_blank"
                      >
                        View on OpenSea
                      </a>
                    </button>
                    <button style={modalButton}>
                      {txData && txData.transactionHash ? (
                        <a
                          href={`https://mumbai.polygonscan.com/tx/${txData.transactionHash}`}
                          target="_blank"
                        >
                          View on Polygonscan
                        </a>
                      ) : undefined}
                    </button>
                    <button onClick={() => setModalShow(false)} style={modalButton}>
                      Close
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}
        </main>
      ) : (
        <main className={styles.main}>
          <div>Please connect your wallet.</div>
        </main>
      )}
    </div>
  );
}

const header = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  paddingTop: "20px",
  paddingLeft: "50px",
  paddingRight: "50px",
};

const NFTFlex = {
  display: "flex",
  alignItems: "center",
  justifyContent: "space-evenly",
  gap: "50px",
};

const NFTCard = {
  display: "flex",
  flexDirection: "column",
  border: "2px solid white",
  borderRadius: "10px",
  padding: "20px",
  alignItems: "center",
  gap: "10px",
  fontWeight: "bold",
};

const NFTMint = {
  fontWeight: "700",
  padding: "5px 20px",
  border: "2px solid white",
  color: "white",
  backgroundColor: "black",
  borderRadius: "5px",
  cursor: "pointer",
};

const modal = {
  position: "fixed",
  left: "0",
  top: "0",
  right: "0",
  bottom: "0",
  backgroundColor: "rgba(0, 0, 0, 0.8)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  zIndex: "1",
};

const modalContent = {
  backgroundColor: "#fff",
  padding: "10px 30px",
  borderRadius: "16px",
  color: "#000",
};

const modalBody = {
  padding: "20px",
  borderTop: "1px solid #eee",
  borderBottom: "1px solid #eee",
};

const modalFooter = {
  display: "flex",
  flexDirection: "column",
  gap: "10px",
  padding: "20px",
  justifyContent: "space-evenly",
};

const modalButton = {
  padding: "10px 20px",
  backgroundColor: "#fff",
  color: "#666",
  border: "0",
  borderRadius: "10px",
  fontSize: "18px",
  fontWeight: "700",
  boxShadow: "0 0.2em 0.4em 0 rgba(0, 0, 0, 0.2), 0 0.3em 1em 0 rgba(0, 0, 0, 0.19)",
};
```

</LessonInformationalModal>
<br/>
<br/>

<br />
<br />
<QuizStatusChecker quiz="nft-solidity/quiz-nft-solidity-5" />
<br />
<br />

## Fin.

**Hoorah! We've done it. Pat yourselves on the back and get some ice cream!**

Right from learning the basics of smart contract development using solidity to
creating a full stack decentralised NFT Minting Application.

**Stay tuned for more!**

## <br/>

<br/>
</LessonLayout>
```
